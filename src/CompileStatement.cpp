#include <backend/compiler_visitors.h>
#include <backend/CompilerUtil.h>
#include <backend/CompilerContext.h>
#include <llvm/IR/Verifier.h>

// now it goes through the data structure generated by CompielHighLevel and
// compiles the lower level (so return statements and expressions)
// this is the final stage
CompileStatement::CompileStatement(llvm::Module &module, llvm::IRBuilder<> &builder, llvm::LLVMContext &context,
                                   CompilerContext compiler_context, llvm::StructType *params) : module(module), builder(builder), context(context)
{
    this->compiler_context = compiler_context;
    this->program_scope = compiler_context.getScope();
    this->params = params;
}

void CompileStatement::Visit(ASTNode *node)
{
}

void CompileStatement::Visit(FunctionNode *node)
{

    // all functions are stored in a stack. the compiler pulls a function from the stack
    // sees if its a global or local function
    // if local we put it in the local scope. if global we generate it
    auto c = this->program_scope.set_current_function();

    // the anonmoous prevents collisons
    if (c.isAnonymous)
    {
        llvm::BasicBlock *EntryBlock = llvm::BasicBlock::Create(context, "entry", c.function);
        this->block = EntryBlock;
        builder.SetInsertPoint(EntryBlock);
    }
    else if (this->program_scope.get_inmodule_global_function(c.name).has_value())
    {
        auto func = program_scope.get_inmodule_global_function(node->f->FunctionName).value();
        llvm::BasicBlock *EntryBlock = llvm::BasicBlock::Create(context, "entry", func.function);
        this->block = EntryBlock;

        builder.SetInsertPoint(EntryBlock);
    }
    else
    {
        program_scope.addLocal(c.name, c);
        llvm::BasicBlock *EntryBlock = llvm::BasicBlock::Create(context, "entry", c.function);
        this->block = EntryBlock;
        builder.SetInsertPoint(EntryBlock);
    }
    for (int i = 0; i < node->stmnts.size(); i++)
    {
        node->stmnts[i]->Accept(this);
    }
}

void CompileStatement::Visit(ModuleNode *node)
{
    auto functions = node->functions;
    std::reverse(functions.begin(), functions.end());
    for (int i = 0; i < node->functions.size(); i++)
    {
        // program_scope.set_current(node->name);
        functions[i]->Accept(this);
    }
}

void CompileStatement::Visit(ReturnNode *node)
{

    CompileExpr c(module, builder, context, compiler_context, this->program_scope, this->block, this->params);

    auto ty = compiler_context.get_type(program_scope.get_current_function().ret_type);
    // auto value = builder.CreateLoad(ty.get_type(), c.Expression(node->Expr));
    // program_scope.get_current_function().function->viewCFGOnly();
    llvm::raw_ostream *output = &llvm::outs();

    auto value = c.Expression(node->Expr);
    this->block = value.block;
    auto f = program_scope.get_current_function().function;
    llvm::Argument *ret_ptr = f->getArg(1);
    if (program_scope.get_current_function().name.value != "main")
    {
        value.value = ValueOrLoad(builder, value.value, ty.get_type());
        builder.CreateStore(value.value, ret_ptr);
    }

    builder.CreateRetVoid();
    auto error = llvm::verifyFunction(*(f), output);
}

void CompileStatement::Visit(ProgramNode *node)
{
    for (const auto &[key, current_module] : node->avail_modules)
    {
        program_scope.set_current(current_module->name);
        current_module->Accept(this);
    }
}
